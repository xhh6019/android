#!/usr/bin/perl -w

# this file is used to automatically generate the target build env based on external build spec and the default configuration value.
use strict;
use Cwd;
use Data::Dumper;
my $use_ext_spec = 0;
my $buildspec_file;
my $dir = getcwd; 
my $configuration_file = "build/buildplus/namespace/names.ini";
my $targetmin_path = "build/buildplus/target/QRDExt_target.min";
my $targethfile_path = "build/buildplus/target/QRDExt_target.h";
my $targetjava_path = "build/buildplus/target/FeatureQuery.java";
my $targetjavadefaultval_path = "build/buildplus/target/DefaultQuery.java";
my %buildspec_sections;
my %component_list;
my %javafeature_list;
my %nativefeature_list;
my %javadefaultval_list;
my %nativedefaultval_list;
my $sectionName = "UnDefined" ;
my $section     = {};
my $line;
my $component_sec_name = "Modules";
my $javafeature_sec_name = "Java Feature";
my $nativefeature_sec_name = "Native Feature";
my $javadefaultval_sec_name = "Java Default Value";
my $nativedefaultval_sec_name = "Native Default Value";
local *FP;
my ($key, $value);

if (defined $ARGV[0]) {
    $buildspec_file = "build/buildplus/buildspec/" . $ARGV[0] . ".spec";
    $use_ext_spec = 1;
}

#read build spec
if ($use_ext_spec) {
    open(FP,"<$buildspec_file") or die "read(): can't open $buildspec_file for read: $!";
    while (defined ($line = <FP>))
    {
      chomp($line);
      
      if ($line =~ /^\s*(;.*)?$/) # Comment
         {
         }
      elsif ($line =~ /^\s*(.*?)\s*=\s*(.*?)\s*(;.*)?$/) # Assignment 
         {
          my $left  = $1;
          my $right = $2;
          $buildspec_sections{$sectionName}{$left} = $right;  
         }
      elsif ($line =~ /^\s*\[\s*(.*?)\s*\]\s*(;.*)?$/) # Section name
         {
          $sectionName = $1;
         }
      else
         {
          die "read(): illegal line <$line> in file $buildspec_file.";
         }
    } 
    close(FP);
}

#read configuration List

open(FP,"<$configuration_file") or die "read(): can't open $configuration_file for read: $!";
while (defined ($line = <FP>))
{
  chomp($line);
  if ($line =~ /^\s*(;.*)?$/) # Comment
     {
     }
  elsif ($line =~ /^\s*(.*?)\s*=\s*(.*?)\s*(;.*)?$/) # Assignment 
     {
      my $left  = $1;
      my $right = $2;
      if ($sectionName eq $component_sec_name) {
        $component_list{$left} = $right;        
      } elsif ($sectionName eq $javafeature_sec_name) {
        $javafeature_list{$left} = $right;
      } elsif ($sectionName eq $nativefeature_sec_name) {
        $nativefeature_list{$left} = $right;
      } elsif ($sectionName eq $javadefaultval_sec_name) {
        $javadefaultval_list{$left} = $right;
      } elsif ($sectionName eq $nativedefaultval_sec_name) {
        $nativedefaultval_list{$left} = $right;
      }     
      else {}
      
     }
  elsif ($line =~ /^\s*\[\s*(.*?)\s*\]\s*(;.*)?$/) # Section name
     {
      $sectionName = $1;
     }
  else
     {
      die "read(): illegal line <$line> in file $configuration_file.";
     }
} 
close(FP);


#convergent the Build spec and default component definition and out put the target.min

if(-e $targetmin_path)
{
    system("rm -rf $targetmin_path");
}    
open(FP,">$targetmin_path") or die "write(): can't open $targetmin_path for write: $!";
print FP "####--------this is auto generated by build engine, it is for component build config, PLS do not manually modify it--------####\n";

#print Data::Dumper->Dump([\%component_list],[qw(component_list)]);

foreach $key (sort keys %component_list)
{
    $value = $component_list{$key};
    if ($use_ext_spec) {
        if (exists $buildspec_sections{$component_sec_name}{$key})
        {
            $value = $buildspec_sections{$component_sec_name}{$key};
        }
    }
    print FP "$key:=$value\n";
}
close(FP);


#convergent the Build spec and default java feature definition and out put to the FeatureQuery.java

if(-e $targetjava_path)
{
    system("rm -rf $targetjava_path");
}    
open(FP,">$targetjava_path") or die "write(): can't open $targetjava_path for write: $!";
print FP "/*--------this is auto generated by build engine, it is for Java Feature build config, PLS do not modify manually--------*/\n";
print FP "package com.qrd.plugin.feature_query;\n\npublic class FeatureQuery {\n";
#print Data::Dumper->Dump([\%component_list],[qw(component_list)]);

foreach $key (sort keys %javafeature_list)
{
    $value = $javafeature_list{$key};
    if ($use_ext_spec) {
        if (exists $buildspec_sections{$javafeature_sec_name}{$key})
        {
            $value = $buildspec_sections{$javafeature_sec_name}{$key};
        }
    }
    if ($value eq 'yes') {
        $value = 'true';
    } else
    {
        $value = 'false';
    }
    print FP "    public static  boolean $key = $value;\n";
}
print FP "}";
close(FP);

#convergent the Build spec and default native feature definition/Default native value and out put to the QRDExt_target.h
if(-e $targethfile_path)
{
    system("rm -rf $targethfile_path");
}    
open(FP,">$targethfile_path") or die "write(): can't open $targethfile_path for write: $!";
print FP "/*--------this is auto generated by build engine, it is for native Feature/Default Value build config, PLS do not modify manually--------*/\n";
print FP "#ifndef _QRDEXT_TARGET_H_\n#define _QRDEXT_TARGET_H_\n\n\n";
#print Data::Dumper->Dump([\%component_list],[qw(component_list)]);

print FP "//Start Native Feature Definition\n";
foreach $key (sort keys %nativefeature_list)
{
    $value = $nativefeature_list{$key};
    if ($use_ext_spec) {
        if (exists $buildspec_sections{$nativefeature_sec_name}{$key})
        {
            $value = $buildspec_sections{$nativefeature_sec_name}{$key};
        }
    }
    if ($value eq 'yes') {
        $value = '1';
    } else
    {
        $value = '0';
    }
    print FP "#define $key    $value\n";
}
print FP "\n\n//Start Native Default Value Definition\n";

foreach $key (sort keys %nativedefaultval_list)
{
    $value = $nativedefaultval_list{$key};
    if ($use_ext_spec) {
        if (exists $buildspec_sections{$nativedefaultval_sec_name}{$key})
        {
            $value = $buildspec_sections{$nativedefaultval_sec_name}{$key};
        }
    }
    print FP "#define $key    $value\n";
}

print FP "\n\n#endif";
close(FP);

#convergent the Build spec and default native feature definition and out put to the DefaultQuery.java
if(-e $targetjavadefaultval_path)
{
    system("rm -rf $targetjavadefaultval_path");
}    
open(FP,">$targetjavadefaultval_path") or die "write(): can't open $targetjavadefaultval_path for write: $!";
print FP "/*--------this is auto generated by build engine, it is for Java Default Value build config, PLS do not modify manually--------*/\n";
print FP "package com.qrd.plugin.feature_query;\n\npublic class DefaultQuery {\n";
#print Data::Dumper->Dump([\%component_list],[qw(component_list)]);

foreach $key (sort keys %javadefaultval_list)
{
    $value = $javadefaultval_list{$key};
    my $RealKey = $key; 
    my $type ="";
    if ($key =~ /^(.*?)<(.*?)>$/) {
    $RealKey = $1;
    $type = $2;
    }    
    
    if ($use_ext_spec) {
        if (exists $buildspec_sections{$javadefaultval_sec_name}{$RealKey})
        {
            $value = $buildspec_sections{$javadefaultval_sec_name}{$RealKey};
        }
    }

    print FP "    public static  $type $RealKey = $value;\n";
}
print FP "}";
close(FP);


print "GEN_SUCCESS";
#TODO, native feature and prop, defaultvalueQuery.java